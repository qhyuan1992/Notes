## 内存分析

[TOC]

### 1.进程可使用的内存

两个方法获取应用得可用内存大小：

- ActivityManager.getMemoryClass()
- ActivityManager.getLargeMemoryClass()

/system/build.prop文件，或者

```
dalvik.vm.heapstartsize=8m
dalvik.vm.heapgrowthlimit=128m
dalvik.vm.heapsize=512m
```

**dalvik.vm.heapstartsize=8m**

相当于虚拟机的 -Xms配置，设置堆内存的初始大小。

**dalvik.vm.heapgrowthlimit=128m**

相当于虚拟机的 -XX:HeapGrowthLimit配置，一个应用的最大堆内存大小

**dalvik.vm.heapsize=512m**

当于虚拟机的 -Xmx配置，设置了使用android:largeHeap的应用的最大堆内存大小。

可以在manifest文件application节点加入android:largeHeap=“true”即可使应用的最大内存增大。

###2.应用什么时候被杀死

移动终端内存有限，当前可用内存不够时，会根据按应用进程类型的优先级和内存占用大小结束进程

- 超过虚拟机内存上限会抛出OOM，程序崩溃，上限根据largeHeap参数可能是heapsize或heapgrowthlimit

- 通过Low memory killer机制杀死进程。Low memory killer指定了一组内存临界值。若某个进程的进程描述符中的oom_adj在同一范围，该进程将被杀死。

- /sys/module/lowmemorykiller/parameters/adj和/sys/module/lowmemorykiller/parameters/minfree

  0,58,117,176,529,1000

  15360,19200,23040,26880,34415,43737

  | **级别类型** | **oom_adj** | 内存警戒值( 以4K为单位） |
  | -------- | ----------- | -------------- |
  | 前台进程     | 0           | 1536           |
  | 可见进程     | 1           | 2048           |
  | 后台服务     | 2           | 4096           |
  | 桌面程序     | 4           |                |
  | 后台进程     | 7           | 5120           |
  | 内容供应点    | 14          | 5632           |
  | 缓存进程     | 15          | 6144           |

当前可用内存小于5120*4K=20M时，所有oom_adj值大于7的进程都会被kill，相同的oom_adj下，内存大的，优先被杀。

- 查看下一个可能被杀的进程 dumpsys meminfo --oom

### 3.OOM

Android系统对dalvik的vm heapsize作了硬性限制，当java进程申请的java空间超过阈值时，就会抛出OOM异常。程序发生OMM并不表示RAM不足，而是因为程序申请的java heap对象超过了dalvik vm heapgrowthlimit。也就是说，在RAM充足的情况下，也可能发生OOM。

App为什么会OOM呢？其实就是申请的内存太大，而剩余的内存不足以分配这么大

- 数据结构设计不合理，冗余

- 数据本身就太大

- 频繁的分配导致内存碎片

- 内存泄露，导致内存无法使用

  Native层当无指针指向一段内存空，Java层当生命期较长的引用一直指向对象

### 4.查看应用所占的内存

####4.1procrank



####4.1dumpsys meminfo



#### 4.3AndroidStudio3.0

新版的AndroidStudio3.0推出了Android Profilers工具。启动方法：点击 View->Tool Windows->Android Profiler（也可以直接在工具栏中点击 Android Profiler ）

选择设备/进程后就会显示CPU/MEMORY/NETWORK的实时情况，点击内存区块就会显示当前进程的实时内存情况。

![androidstuido_1.png](./raw/androidstuido_1.png)

垃圾桶图标：手动强制触发Full GC，如果直接dump也会触发

- 下载按钮：dump Java Heap。Dump当前应用的内存分配情况，dump下来的hprof内存文件为非标准的内存文件，如果需要使用MAT工具打开，需要用hprof_conv工具转换
- 红色圆形按钮：实时记录内存分配情况，该功能可以记录某一时间段内内存的分配情况。
- dump堆内存

点击dump下来文件，可以看到一共有三个窗口：

- 左上角区域为当前内存中的全部对象
- 选中某对象，右上角区域显示为该对象的全部实例
- 选中某一个对象，下方可以显示该对象的引用树

![androidstuido_2.png](./raw/androidstuido_2.png)

从上图中发现DashPathEffect对象竟然有5790个，占用内存多达92K，通过对象的引用树可以找到是哪些地方引用了这些对象导致其未被释放，经过定位发现这些对象最终都被AnimatedPathView引用着，并且每个AnimatedPathView都会创建100个DashPathEffect对象，这显然是不合理的。



利用AndroidStudio分析内存的思路：

- dump某个时刻应用得内存情况。根据Retained Size内存大小进行排序
- 优先分析那些内存大的，数量不止一个的对象，通过对象引用链，分析当前对象未被释放的原因
- 思考是否合理，并考虑是否出现了内存泄露、数据结构设计是否合理

#### 4.4MAT

#####使用介绍：

histogram视图

Dominator视图

#####配合GIMP查看Bitmap

使用mat还可以配合GIMP软件查看bitmap。

![mat_gimp_sample_1](./raw/mat_gimp_sample_1.png)

比如我们用MAT查看某时刻的hprof发现一个bitmap占用了1.8M内存。通过定位该bitmap的引用链，可以查看到这个bitmap无法释放的原因。但这仍不有助于我们分析问题到底出在哪里，这时可以通过以下方式定位到这个图片到底是哪个。

![mat_gimp_sample_2](./raw/mat_gimp_sample_2.png)

在左侧的Attributes窗口中包含了关于这个bitmap的相关信息

- mBuffer该bitmap的像素信息
- mHeight和mWidth分别表示bitmap的宽度和高度，这两个参数在后面将会用到

右键mBuffer -> Copy -> Save Value To File，将像素信息保存为xxx.data文件，接下来在GIMP软件中点击文件 -> 打开，选择刚才生成的xxx.data文件，设置好正确的参数就可以查看到对应的bitmap了，这样更容易定位内存问题。

<img src="./raw/mat_gimp_sample_3.png" style="zoom:80%" />



####4.5LeakCanary

LeakCanary是[Square](http://square.github.io/) 公司开源的一个第三方内存泄漏检测库。可以通过简单的方式来让开发者方便的查看到应用的内存泄露情况。

#####使用：

1. `RefWatcher.watch()` 创建一个 [KeyedWeakReference](https://github.com/square/leakcanary/blob/master/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java) 到要被监控的对象。
2. 然后在后台线程检查引用是否被清除，如果没有，调用GC。
3. 如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 `.hprof` 文件中。
4. 在另外一个进程中的 `HeapAnalyzerService` 有一个 `HeapAnalyzer` 使用[HAHA](https://github.com/square/haha) 解析这个文件。
5. 得益于唯一的 reference key, `HeapAnalyzer` 找到 `KeyedWeakReference`，定位内存泄露。
6. `HeapAnalyzer` 计算 *到 GC roots 的最短强引用路径*，并确定是否是泄露。如果是的话，建立导致泄露的引用链。
7. 引用链传递到 APP 进程中的 `DisplayLeakService`， 并以通知的形式展示出来。

`LeakCanary.install()` 会返回一个预定义的 `RefWatcher`，同时也会启用一个 `ActivityRefWatcher`，用于自动监控调用 `Activity.onDestroy()` 之后泄露的 activity。

```java
public class ExampleApplication extends Application {

  public static RefWatcher getRefWatcher(Context context) {
    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
    return application.refWatcher;
  }

  private RefWatcher refWatcher;

  @Override public void onCreate() {
    super.onCreate();
    refWatcher = LeakCanary.install(this);
  }
}

```

使用 `RefWatcher` 监控 Fragment：

```java
public abstract class BaseFragment extends Fragment {

  @Override public void onDestroy() {
    super.onDestroy();
    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());
    refWatcher.watch(this);
  }
}
```

#####如何分析：

当应用发生内存泄漏时，会自动dump内存，分析后以通知的形式展示出来。通过展示出来的引用链就可以清楚地看到内存泄漏的原因。

下面展示了我们APP中的直播间的内存泄漏，具体是Activity泄露

- HandlerThread引用着Message（被局部变量持有？死循环导致未被释放？）

- Message对象引用着VideoRoomPullDownPanelView的第二个匿名内部类（作为Message的obj变量的值）

- 这个匿名内部类又引用着外部的VideoRoomPullDownPanelView（匿名内部类内部引用了外部类this$0）

- 它又引用着VideoRoomActivity，最终导致了该Activity的泄露（VideoRoomPullDownPanelView内部的mContext）

  ​

  <img src="./raw/LeakCanary.png" style="zoom:40%" />


除了LeakCanary，还有一些其他的工具LeakInspector/WxPerformanceTool/LeakParser都可以用于检测内存泄漏

### 5.场景分析（案例分析）

#### 5.1APP处于后台



####5.2

###6优化收益







